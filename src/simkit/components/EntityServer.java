package simkit.components;

import static java.lang.Double.NaN;
import java.util.SortedSet;
import java.util.TreeSet;
import simkit.Entity;
import static simkit.Priority.HIGH;
import simkit.SimEntityBase;
import simkit.random.RandomVariate;

/**
 * Multiple server queue in which customers are explicitly represented as Entity
 * objects. This allows explicitly collecting statistics for delay in queue and
 * time in system without invoking Little's formula, as with SimpleServer.
 *
 * @author ahbuss
 */
public class EntityServer extends SimEntityBase {

    /**
     * This many servers in total
     */
    private int totalNumberServers;

    /**
     * Generates service times
     */
    private RandomVariate serviceTimeGenerator;

    /**
     * Current number of available servers
     */
    protected int numberAvailableServers;

    /**
     * Container holding Entities waiting for service in FIFO manner
     */
    protected SortedSet<Entity> queue;

    /**
     * Delay in queue of last customer who started service
     */
    protected double delayInQueue;

    /**
     * Total time in system for last customer completing service
     */
    protected double timeInSystem;

    /**
     * Instantiate queue
     */
    public EntityServer() {
        this.queue = new TreeSet<>();
    }

    /**
     * Instantiate an EntityServer with given parameters
     *
     * @param totalNumberServers Given total number of servers
     * @param ServiceTimeGenerator Given service time generator
     */
    public EntityServer(int totalNumberServers, RandomVariate ServiceTimeGenerator) {
        this();
        setTotalNumberServers(totalNumberServers);
        setServiceTimeGenerator(ServiceTimeGenerator);
    }

    /**
     * <ul>
     * <li>Initialize numberAvailableServers to totalNumberServers
     * <li>Clear queue
     * <li>Set delayInQueue to NaN
     * <li>Set timeInSystem to NaN
     * </ul>
     */
    @Override
    public void reset() {
        super.reset();
        this.numberAvailableServers = getTotalNumberServers();
        this.queue.clear();
        this.delayInQueue = NaN;
        this.timeInSystem = NaN;
    }

    /**
     * Only firePropertyChangeEvents for state variables' initial values
     */
    public void doRun() {
        firePropertyChange("numberAvailableServers", getNumberAvailableServers());
        firePropertyChange("queue", getQueue());
        firePropertyChange("delayInQueue", getDelayInQueue());
        firePropertyChange("timeInSystem", getTimeInSystem());
    }

    /**
     * <ul>
     * <li>Stamp entity's time
     * <li>Add entity to queue
     * <li>If available servers, schedule StartService with delay 0.0 and HIGH priority
     * </ul>
     * @param entity Arriving customer
     */
    public void doArrival(Entity entity) {
        entity.stampTime();

        SortedSet<Entity> oldQueue = getQueue();
        queue.add(entity);
        firePropertyChange("queue", oldQueue, getQueue());

        if (getNumberAvailableServers() > 0) {
            waitDelay("StartService", 0.0, HIGH);
        }
    }

    /**
     * <ul>
     * <li>Remove first entity from queue
     * <li>Delay in queue is entity's elapsed time
     * <li>decrement numberAvailableServers
     * <li>Schedule EndService with delay generated by serviceTimeGenerator
     * </ul>
     */
    public void doStartService() {
        Entity entity = queue.first();

        delayInQueue = entity.getElapsedTime();
        firePropertyChange("delayInQueue", getDelayInQueue());

        int oldNumberAvailableServers = getNumberAvailableServers();
        numberAvailableServers -= 1;
        firePropertyChange("numberAvailableServers", oldNumberAvailableServers,
                getNumberAvailableServers());

        SortedSet<Entity> oldQueue = getQueue();
        queue.remove(entity);
        firePropertyChange("queue", oldQueue, getQueue());

        waitDelay("EndService", getServiceTimeGenerator(), entity);
    }

    /**
     * <ul>
     * <li>timeInSystem is entity's elapsed time
     * <li>Increment numberAvailableServers
     * <li>If queue is not empty, schedule StartService with delay 0.0 and HIGH priority
     * </ul>
     * @param entity Entity completing service
     */
    public void doEndService(Entity entity) {
        timeInSystem = entity.getElapsedTime();
        firePropertyChange("timeInSystem", getTimeInSystem());

        int oldNumberAvailableServers = getNumberAvailableServers();
        numberAvailableServers += 1;
        firePropertyChange("numberAvailableServers", oldNumberAvailableServers,
                getNumberAvailableServers());

        if (!queue.isEmpty()) {
            waitDelay("StartService", 0.0, HIGH);
        }
    }

    /**
     * @return the totalNumberServers
     */
    public int getTotalNumberServers() {
        return totalNumberServers;
    }

    /**
     *
     * @param totalNumberServers the totalNumberServers to set
     * @throws IllegalArgumentException if totalNumberServers \u2264 0
     */
    public void setTotalNumberServers(int totalNumberServers) {
        if (totalNumberServers <= 0) {
            throw new IllegalArgumentException("totalNumberServers must be > 0: " + totalNumberServers);
        }
        this.totalNumberServers = totalNumberServers;
    }

    /**
     * @return the serviceTimeGenerator
     */
    public RandomVariate getServiceTimeGenerator() {
        return serviceTimeGenerator;
    }

    /**
     * @param serviceTimeGenerator the serviceTimeGenerator to set
     */
    public void setServiceTimeGenerator(RandomVariate serviceTimeGenerator) {
        this.serviceTimeGenerator = serviceTimeGenerator;
    }

    /**
     * @return the numberAvailableServers
     */
    public int getNumberAvailableServers() {
        return numberAvailableServers;
    }

    /**
     * @return the queue
     */
    public SortedSet<Entity> getQueue() {
        return new TreeSet<>(queue);
    }

    /**
     * @return the delayInQueue
     */
    public double getDelayInQueue() {
        return delayInQueue;
    }

    /**
     * @return the timeInSystem
     */
    public double getTimeInSystem() {
        return timeInSystem;
    }

}
